let n="production";function o(o,e){if("development"==n)throw e;throw new Error(o)}function e(n,e,i){n&&o(e,i)}function i(o){n=o}const t={name:"DefaultPlugins",plugins:[new function(){const n=["name","hooks","init","allowKeys","desactivateKeyCheck","plugins","debug","preInit"];let e=!1;return{name:"ValidateConfigPlugin",hooks:{initPlugin(o,i){o.allowKeys&&n.push(...o.allowKeys),o.desactivateKeyCheck&&(e=o.desactivateKeyCheck)},pluginsInitialized(i){if(!e)for(let e of i.plugins)for(let i of Object.keys(e))n.includes(i)||o(`Config attribute "${i}" is used but not allowed. Allowed are ${n.join(", ")}. \n                            You want to disable this proove? set desactivateKeyCheck:true.\n                            You want to allow another config attributes? Add allowKeys:['yourkeyname'].`,"config.invalidKey")}},init:()=>({desactivateKeyCheck(){e=!0}})}},new function(n){return{name:"InitHooksPlugin",allowKeys:["addHooks","hooks"],hooks:{initPlugin:function(n,o){if(n.addHooks){e(Array.isArray(n.addHooks)||"object"!=typeof n.addHooks,`Error in plugin "${n.name}": config.addHooks must be an object but is a ${typeof n.addHooks}`,"config.addHooks.wrongtype");for(let e of Object.keys(n.addHooks))o.hooks[e]=n.addHooks[e]}if(n.hooks){e(Array.isArray(n.hooks)||"object"!=typeof n.hooks,`Error in plugin "${n.name}": config.hooks must be an object but is a ${typeof n.hooks}`,"config.hooks.wrongtype");for(let i of Object.keys(n.hooks))e(!o.hooks[i],'There is no Hook named "'+i+'", declared in plugin '+n.name+' . Is it correctly written? If yes, initialize it first with config attribute "addHooks"',"config.hooks.notDefined"),o.hooks[i].tap(n.name,n.hooks[i])}}},init:function(n,o){return o.config.hooks&&o.config.hooks.preInitPlugin&&o.hooks.preInitPlugin.tap("preInitPlugin",o.config.hooks.preInitPlugin),{addHooks:function(n){for(let e of Object.keys(n))o.hooks[e]=n[e]},on:function(n,e,i){if(!o.hooks[n])throw new Error('Hook with name "'+n+'" does not exist. context.on(name, pluginname, fn) failed');return o.hooks[n].tap(e,i)}}}}},new function(){return{allowKeys:["return"],name:"ReturnPlugin",hooks:{initPlugin(n,o){n.return&&(o.return=n.return)}}}},new function(){const n={};return{allowKeys:["rename"],name:"RenamePlugin",hooks:{initPlugin(o,e){if(o.rename){let e,i;for(i of Object.keys(o.rename))e=o.rename[i],n[i]=e}},return(o){let e,i;for(i of Object.keys(n))e=n[i],o[e]=o[i],delete o[i]}}}},new function(){const n=[];return{allowKeys:["delete"],name:"DeletePlugin",hooks:{initPlugin(o,e){o.delete&&n.push(...o.delete)},return(o){for(let e of n)delete o[e]}}}}]};class r{constructor(){this._listeners={}}tap(n,o){if(null==n)throw new Error("Hook.on(): should be on(name:string, listener:function) but name is undefined");if(null==o)throw new Error("Hook.on(): should be on(name:string, listener:function) but listener is undefined");this._listeners[n]=o}off(n){if(null==n)throw new Error("Hook.off(): should be on(name:string, listener:function) but name is undefined");delete this._listeners[n]}listeners(n){return n?this._listeners[n]:Object.values(this._listeners)}}class l extends r{call(n){const o=this.listeners();for(let n of o)n(...arguments)}}class u extends r{async promise(n){const o=this.listeners();for(let n of o)await n(...arguments)}}class s extends r{call(n){let o=n;const e=this.listeners();for(let n of e){if(null==o)throw new Error("A listener in SyncWaterfallHook.trigger(context) returns null. This is not allowed. Did you forget returning sth in a listener?");o=n(o,...arguments)}return o}}class a extends r{async promise(n){let o=n;const e=this.listeners();for(let n of e)o=await n(o,...arguments);return o}}class f extends r{call(n){const o=this.listeners();for(let n of o){if(!n(...arguments))return}}}class g extends r{async call(n){const o=this.listeners();for(let n of o){if(!await n(...arguments))return}}}const c=function n(o={},r={}){function f(r={}){const f=Object.assign({configs:[]},o);let g=Array.isArray(r)?r:[r];g=g.map((n=>(n.name=n.name||"pluginize(config)",n))),f.configs.push(...g);const c=function(n){async function o(n,i){if(i.log('- Add plugin "'+n.name+'"'),e(!(n=await i.hooks.preInitPlugin.promise(n,i)||n).name,`Plugin ${JSON.stringify(n)} has no name. Please define a name by adding an attribute name:"pluginname" to your plugin.`,"plugin.noName"),e("function"==typeof n,`Plugin ${n.name} is a function, but should be a configuration object. Did you forget calling it? (eg: PluginName())`,"plugin.isFunction"),e("object"!=typeof n||Array.isArray(n),`Plugin ${n.name} should be a configuration of type object, but is typeof ${typeof n}.`,"plugin.wrongType"),i.plugins.push(n),n.init){e("function"!=typeof n.init,`Error in plugin "${n.name}": config.init must be a function but is a ${typeof n.init}`,"config.init.wrongtype"),i.log("- Execute init() function of plugin "+n.name);const o=await n.init(n,i);if(o&&!o._context&&"object"==typeof o&&!Array.isArray(o))for(let n of Object.keys(o)||{})i.log("- add "+n+" to global context."),i[n]=o[n]}n.hooks&&n.hooks.initPlugin&&await i.hooks.initPlugin.tap(n.name,n.hooks.initPlugin),e(n.plugins&&!Array.isArray(n.plugins),`Error in plugin "${n.name}": config.plugin must be an array but is an ${typeof n.plugins}`,"config.plugin.wrongtype");for(let e of n.plugins||[])await o(e,i);return i}return async function(r={}){let l={plugins:[],config:r,_context:!0,addPlugin:o,hooks:{return:new u(["context"]),preInitPlugin:new a(["config","context"]),pluginsInitialized:new u(["context"]),initPlugin:new u(["plugin","context"])},log(){r.debug&&console.log(...arguments)}};n.preInit&&(r=await n.preInit(r,l)),e(null==r,"pluginize(config,factoryConfig): factoryConfig.preInit returns null but should return the modified config.","factoryConfig.preInit.isNull"),e("object"!=typeof r,"pluginize(config,factoryConfig): factoryConfig.preInit returns a "+typeof entry+"but should return an object.","factoryConfig.preInit.wrongType"),e(Array.isArray(r),"pluginize(config,factoryConfig): factoryConfig.preInit returns an Array but should return an object.","factoryConfig.preInit.wrongTypeArray"),r.debug&&i("development"),r.name||(r.name="PluginizeAsync"),l.log("Starting Pluginize."),await o(t,l);for(let e of n.configs)await o(e,l);await o(r,l);for(let n of l.plugins)e(null==n,"error in Pluginize(config): hook preInitPlugin - a listener returns null but should  return an object (the modified config)","config.preInit.returnNull"),e(Array.isArray(n)||"object"!=typeof n,"error in Pluginize(config): hook preInitPlugin - a listener should return an object (the modified config) but returns a "+typeof n,"config.preInit.wrongType"),l.log('- call hook "initPlugin" of plugin '+n.name),await l.hooks.initPlugin.promise(n,l);return l.log('- call hook "pluginsInitialized"'),await l.hooks.pluginsInitialized.promise(l),await l.hooks.return.promise(l),l.return?l[l.return]:l}}(f);return new n(f,{runPromise:c,run:function(n){function o(n,i){if(i.log('- Add plugin "'+n.name+'"'),e(null==(n=i.hooks.preInitPlugin.call(n,i)||n),"Error: Plugin is null","conf.isNull"),e(!n.name,`Plugin ${JSON.stringify(n)} has no name. Please define a name by adding an attribute name:"pluginname" to your plugin.`,"plugin.noName"),e("function"==typeof n,`Plugin ${n.name} is a function, but should be a configuration object. Did you forget calling it? (eg: PluginName())`,"plugin.isFunction"),e("object"!=typeof n||Array.isArray(n),`Plugin ${n.name} should be a configuration of type object, but is typeof ${typeof n}.`,"plugin.wrongType"),i.plugins.push(n),n.init){e("function"!=typeof n.init,`Error in plugin "${n.name}": config.init must be a function but is a ${typeof n.init}`,"config.init.wrongtype"),i.log("- Execute init() function of plugin "+n.name);const o=n.init(n,i);if(o&&!o._context&&"object"==typeof o&&!Array.isArray(o))for(let n of Object.keys(o)||{})i.log("- add "+n+" to global context."),i[n]=o[n]}n.hooks&&n.hooks.initPlugin&&i.hooks.initPlugin.tap(n.name,n.hooks.initPlugin),e(n.plugins&&!Array.isArray(n.plugins),`Error in plugin "${n.name}": config.plugin must be an array but is an ${typeof n.plugins}`,"config.plugin.wrongtype");for(let e of n.plugins||[])o(e,i);return i}return function(r={}){let u={plugins:[],config:r,_context:!0,addPlugin:o,hooks:{return:new l(["context"]),preInitPlugin:new s(["config","context"]),pluginsInitialized:new l(["context"]),initPlugin:new l(["plugin","context"])},log(){r.debug&&console.log(...arguments)}};const a=n.configs[n.configs.length-1];a.preInit&&(r=a.preInit(r,u)||r),e(null==r,"pluginize(config,factoryConfig): factoryConfig.preInit returns null but should return the modified config.","factoryConfig.preInit.isNull"),e("object"!=typeof r,"pluginize(config,factoryConfig): factoryConfig.preInit returns a "+typeof entry+"but should return an object.","factoryConfig.preInit.wrongType"),e(Array.isArray(r),"pluginize(config,factoryConfig): factoryConfig.preInit returns an Array but should return an object.","factoryConfig.preInit.wrongTypeArray"),r.debug&&i("development"),r.name||(r.name="Pluginize"),u.log("Starting Pluginize."),o(t,u);for(let e of n.configs)o(e,u);o(r,u);for(let n of u.plugins)e(null==n,"error in Pluginize(config): hook preInitPlugin - a listener returns null but should  return an object (the modified config)","config.preInit.returnNull"),e(Array.isArray(n)||"object"!=typeof n,"error in Pluginize(config): hook preInitPlugin - a listener should return an object (the modified config) but returns a "+typeof n,"config.preInit.wrongType"),u.log('- call hook "initPlugin" of plugin '+n.name),u.hooks.initPlugin.call(n,u);return u.log('- call hook "pluginsInitialized"'),u.hooks.pluginsInitialized.call(u),u.hooks.return.call(u),u.return?u[u.return]:u}}(f),factoryConfig:f})}for(let n of Object.keys(r))f[n]=r[n];return f}({});export{g as AsyncBreakableHook,u as AsyncHook,a as AsyncWaterfallHook,f as SyncBreakableHook,l as SyncHook,s as SyncWaterfallHook,c as pluginize};
