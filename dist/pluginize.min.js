! function(n, o) { "object" == typeof exports && "undefined" != typeof module ? o(exports) : "function" == typeof define && define.amd ? define(["exports"], o) : o((n = "undefined" != typeof globalThis ? globalThis : n || self).pluginize = {}) }(this, (function(n) {
    "use strict";
    let o = "production";

    function i(n, i) { if ("development" == o) throw i; throw new Error(n) }

    function e(n, o, e) { n && i(o, e) }

    function t(n) { o = n }
    const r = {
        name: "DefaultPlugins",
        plugins: [new function() {
            const n = ["name", "hooks", "init", "allowKeys", "desactivateKeyCheck", "plugins", "debug", "changeConfig"];
            let o = !1;
            return {
                name: "ValidateConfigPlugin",
                hooks: {
                    initPlugin(i, e) { i.allowKeys && n.push(...i.allowKeys), i.desactivateKeyCheck && (o = i.desactivateKeyCheck) },
                    pluginsInitialized(e) {
                        if (!o)
                            for (let o of e.plugins)
                                for (let e of Object.keys(o)) n.includes(e) || i(`Config attribute "${e}" is used but not allowed. Allowed are ${n.join(", ")}. \n                            You want to disable this proove? set desactivateKeyCheck:true.\n                            You want to allow another config attributes? Add allowKeys:['yourkeyname'].`, "config.invalidKey")
                    }
                },
                init: () => ({ desactivateKeyCheck() { o = !0 } })
            }
        }, new function(n) { return { name: "InitHooksPlugin", allowKeys: ["addHooks", "hooks"], hooks: { initPlugin: function(n, o) { if (n.addHooks) { e(Array.isArray(n.addHooks) || "object" != typeof n.addHooks, `Error in plugin "${n.name}": config.addHooks must be an object but is a ${typeof n.addHooks}`, "config.addHooks.wrongtype"); for (let i of Object.keys(n.addHooks)) o.hooks[i] = n.addHooks[i] } if (n.hooks) { e(Array.isArray(n.hooks) || "object" != typeof n.hooks, `Error in plugin "${n.name}": config.hooks must be an object but is a ${typeof n.hooks}`, "config.hooks.wrongtype"); for (let i of Object.keys(n.hooks)) e(!o.hooks[i], 'There is no Hook named "' + i + '", declared in plugin ' + n.name + ' . Is it correctly written? If yes, initialize it first with config attribute "addHooks"', "config.hooks.notDefined"), o.hooks[i].tap(n.name, n.hooks[i]) } } }, init: function(n, o) { return o.config.hooks && o.config.hooks.preInitPlugin && o.hooks.preInitPlugin.tap("preInitPlugin", o.config.hooks.preInitPlugin), { addHooks: function(n) { for (let i of Object.keys(n)) o.hooks[i] = n[i] }, on: function(n, i, e) { if (!o.hooks[n]) throw new Error('Hook with name "' + n + '" does not exist. context.on(name, pluginname, fn) failed'); return o.hooks[n].tap(i, e) } } } } }, new function() { return { allowKeys: ["return"], name: "ReturnPlugin", hooks: { initPlugin(n, o) { n.return && (o.return = n.return) } } } }, new function() { const n = {}; return { allowKeys: ["rename"], name: "RenamePlugin", hooks: { initPlugin(o, i) { if (o.rename) { let i, e; for (e of Object.keys(o.rename)) i = o.rename[e], n[e] = i } }, return (o) { let i, e; for (e of Object.keys(n)) i = n[e], o[i] = o[e], delete o[e] } } } }, new function() { const n = []; return { allowKeys: ["delete"], name: "DeletePlugin", hooks: { initPlugin(o, i) { o.delete && n.push(...o.delete) }, return (o) { for (let i of n) delete o[i] } } } }]
    };
    class l {
        constructor() { this._listeners = {} }
        tap(n, o) {
            if (null == n) throw new Error("Hook.on(): should be on(name:string, listener:function) but name is undefined");
            if (null == o) throw new Error("Hook.on(): should be on(name:string, listener:function) but listener is undefined");
            this._listeners[n] = o
        }
        off(n) {
            if (null == n) throw new Error("Hook.off(): should be on(name:string, listener:function) but name is undefined");
            delete this._listeners[n]
        }
        listeners(n) { return n ? this._listeners[n] : Object.values(this._listeners) }
    }
    class u extends l { call(n) { const o = this.listeners(); for (let n of o) n(...arguments) } }
    class a extends l { async promise(n) { const o = this.listeners(); for (let n of o) await n(...arguments) } }
    class s extends l {
        call(n) {
            let o = n;
            const i = this.listeners();
            for (let n of i) {
                if (null == o) throw new Error("A listener in SyncWaterfallHook.trigger(context) returns null. This is not allowed. Did you forget returning sth in a listener?");
                o = n(o, ...arguments)
            }
            return o
        }
    }
    class g extends l { async promise(n) { let o = n; const i = this.listeners(); for (let n of i) o = await n(o, ...arguments); return o } }
    const f = ["resolve", "init"];
    n.AsyncBreakableHook = class extends l { async call(n) { const o = this.listeners(); for (let n of o) { if (!await n(...arguments)) return } } }, n.AsyncHook = a, n.AsyncWaterfallHook = g, n.SyncBreakableHook = class extends l { call(n) { const o = this.listeners(); for (let n of o) { if (!n(...arguments)) return } } }, n.SyncHook = u, n.SyncWaterfallHook = s, n.pluginize = function(n = {}, o = {}) {
        const i = Object.assign({ configs: [], plugins: [] }, o);
        e(!Array.isArray(i.plugins), "pluginize(config,factoryConfig): factoryConfig.plugins should be null or an Array but is typeof " + typeof i.plugins, "factoryConfig.plugins.wrongType");
        let l = Array.isArray(n) ? n : [n];
        l = l.map((n => (n.name = n.name || "pluginize(config)", n))), i.configs.push(...l);
        for (let n of i.plugins) e("object" != typeof n || Array.isArray(n), "pluginize(config,factoryConfig): A plugin in factoryConfig.plugins is typeof " + typeof n + " but should be an object", "factoryConfig.plugins.plugin.wrongType"), e(Object.keys(n).some((n => !f.includes(n))), `pluginize(config,factoryConfig): A plugin in factoryConfig.plugins has an invalid key. only ${f.join(",")} is allowed.`, "factoryConfig.plugins.plugin.wrongkey"), e(Object.keys(n).some((o => "function" != typeof n[o])), "pluginize(config,factoryConfig): A plugin in factoryConfig.plugins has an invalid type. It must be typeof function.", "factoryConfig.plugins.plugin.wrongkeytype"), n.init && n.init(i);
        let c = {
            runPromise: function(n) {
                async function o(n, i) {
                    if (i.log('- Add plugin "' + n.name + '"'), e(!(n = await i.hooks.preInitPlugin.promise(n, i) || n).name, `Plugin ${JSON.stringify(n)} has no name. Please define a name by adding an attribute name:"pluginname" to your plugin.`, "plugin.noName"), e("function" == typeof n, `Plugin ${n.name} is a function, but should be a configuration object. Did you forget calling it? (eg: PluginName())`, "plugin.isFunction"), e("object" != typeof n || Array.isArray(n), `Plugin ${n.name} should be a configuration of type object, but is typeof ${typeof n}.`, "plugin.wrongType"), i.plugins.push(n), n.init) {
                        e("function" != typeof n.init, `Error in plugin "${n.name}": config.init must be a function but is a ${typeof n.init}`, "config.init.wrongtype"), i.log("- Execute init() function of plugin " + n.name);
                        const o = await n.init(n, i);
                        if (o && !o._context && "object" == typeof o && !Array.isArray(o))
                            for (let n of Object.keys(o) || {}) i.log("- add " + n + " to global context."), i[n] = o[n]
                    }
                    n.hooks && n.hooks.initPlugin && await i.hooks.initPlugin.tap(n.name, n.hooks.initPlugin), e(n.plugins && !Array.isArray(n.plugins), `Error in plugin "${n.name}": config.plugin must be an array but is an ${typeof n.plugins}`, "config.plugin.wrongtype");
                    for (let e of n.plugins || []) await o(e, i);
                    return i
                }
                return async function(i = {}) {
                    let l = { plugins: [], config: i, _context: !0, addPlugin: o, hooks: { return: new a(["context"]), preInitPlugin: new g(["config", "context"]), pluginsInitialized: new a(["context"]), initPlugin: new a(["plugin", "context"]) }, log() { i.debug && console.log(...arguments) } };
                    n.changeConfig && (i = await n.changeConfig(i, l)), e(null == i, "pluginize(config,factoryConfig): factoryConfig.changeConfig returns null but should return the modified config.", "factoryConfig.changeConfig.isNull"), e("object" != typeof i, "pluginize(config,factoryConfig): factoryConfig.changeConfig returns a " + typeof entry + "but should return an object.", "factoryConfig.changeConfig.wrongType"), e(Array.isArray(i), "pluginize(config,factoryConfig): factoryConfig.changeConfig returns an Array but should return an object.", "factoryConfig.changeConfig.wrongTypeArray"), i.debug && t("development"), i.name || (i.name = "PluginizeAsync"), l.log("Starting Pluginize."), await o(r, l);
                    for (let i of n.configs) await o(i, l);
                    await o(i, l);
                    for (let n of l.plugins) e(null == n, "error in Pluginize(config): hook preInitPlugin - a listener returns null but should  return an object (the modified config)", "config.changeConfig.returnNull"), e(Array.isArray(n) || "object" != typeof n, "error in Pluginize(config): hook preInitPlugin - a listener should return an object (the modified config) but returns a " + typeof n, "config.changeConfig.wrongType"), l.log('- call hook "initPlugin" of plugin ' + n.name), await l.hooks.initPlugin.promise(n, l);
                    return l.log('- call hook "pluginsInitialized"'), await l.hooks.pluginsInitialized.promise(l), await l.hooks.return.promise(l), l.return ? l[l.return] : l
                }
            }(i),
            run: function(n) {
                function o(n, i) {
                    if (i.log('- Add plugin "' + n.name + '"'), e(null == (n = i.hooks.preInitPlugin.call(n, i) || n), "Error: Plugin is null", "conf.isNull"), e(!n.name, `Plugin ${JSON.stringify(n)} has no name. Please define a name by adding an attribute name:"pluginname" to your plugin.`, "plugin.noName"), e("function" == typeof n, `Plugin ${n.name} is a function, but should be a configuration object. Did you forget calling it? (eg: PluginName())`, "plugin.isFunction"), e("object" != typeof n || Array.isArray(n), `Plugin ${n.name} should be a configuration of type object, but is typeof ${typeof n}.`, "plugin.wrongType"), i.plugins.push(n), n.init) {
                        e("function" != typeof n.init, `Error in plugin "${n.name}": config.init must be a function but is a ${typeof n.init}`, "config.init.wrongtype"), i.log("- Execute init() function of plugin " + n.name);
                        const o = n.init(n, i);
                        if (o && !o._context && "object" == typeof o && !Array.isArray(o))
                            for (let n of Object.keys(o) || {}) i.log("- add " + n + " to global context."), i[n] = o[n]
                    }
                    n.hooks && n.hooks.initPlugin && i.hooks.initPlugin.tap(n.name, n.hooks.initPlugin), e(n.plugins && !Array.isArray(n.plugins), `Error in plugin "${n.name}": config.plugin must be an array but is an ${typeof n.plugins}`, "config.plugin.wrongtype");
                    for (let e of n.plugins || []) o(e, i);
                    return i
                }
                return function(i = {}) {
                    let l = { plugins: [], config: i, _context: !0, addPlugin: o, hooks: { return: new u(["context"]), preInitPlugin: new s(["config", "context"]), pluginsInitialized: new u(["context"]), initPlugin: new u(["plugin", "context"]) }, log() { i.debug && console.log(...arguments) } };
                    n.changeConfig && (i = n.changeConfig(i, l)), e(null == i, "pluginize(config,factoryConfig): factoryConfig.changeConfig returns null but should return the modified config.", "factoryConfig.changeConfig.isNull"), e("object" != typeof i, "pluginize(config,factoryConfig): factoryConfig.changeConfig returns a " + typeof entry + "but should return an object.", "factoryConfig.changeConfig.wrongType"), e(Array.isArray(i), "pluginize(config,factoryConfig): factoryConfig.changeConfig returns an Array but should return an object.", "factoryConfig.changeConfig.wrongTypeArray"), i.debug && t("development"), i.name || (i.name = "Pluginize"), l.log("Starting Pluginize."), o(r, l);
                    for (let i of n.configs) o(i, l);
                    o(i, l);
                    for (let n of l.plugins) e(null == n, "error in Pluginize(config): hook preInitPlugin - a listener returns null but should  return an object (the modified config)", "config.changeConfig.returnNull"), e(Array.isArray(n) || "object" != typeof n, "error in Pluginize(config): hook preInitPlugin - a listener should return an object (the modified config) but returns a " + typeof n, "config.changeConfig.wrongType"), l.log('- call hook "initPlugin" of plugin ' + n.name), l.hooks.initPlugin.call(n, l);
                    return l.log('- call hook "pluginsInitialized"'), l.hooks.pluginsInitialized.call(l), l.hooks.return.call(l), l.return ? l[l.return] : l
                }
            }(i)
        };
        for (let n of i.plugins) n.resolve && (c = n.resolve(c) || c);
        return c
    }, Object.defineProperty(n, "__esModule", { value: !0 })
}));