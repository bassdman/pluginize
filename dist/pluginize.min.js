!function(n,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((n="undefined"!=typeof globalThis?globalThis:n||self).pluginize={})}(this,(function(n){"use strict";let e="production";function o(n,o){if("development"==e)throw o;throw new Error(n)}function i(n,e,i){n&&o(e,i)}function t(n){e=n}const r={name:"DefaultPlugins",plugins:[new function(){const n=["name","hooks","init","allowKeys","desactivateKeyCheck","plugins","debug","preInit"];let e=!1;return{name:"ValidateConfigPlugin",hooks:{initPlugin(o,i){o.allowKeys&&n.push(...o.allowKeys),o.desactivateKeyCheck&&(e=o.desactivateKeyCheck)},pluginsInitialized(i){if(!e)for(let e of i.plugins)for(let i of Object.keys(e))n.includes(i)||o(`Config attribute "${i}" is used but not allowed. Allowed are ${n.join(", ")}. \n                            You want to disable this proove? set desactivateKeyCheck:true.\n                            You want to allow another config attributes? Add allowKeys:['yourkeyname'].`,"config.invalidKey")}},init:()=>({desactivateKeyCheck(){e=!0}})}},new function(n){return{name:"InitHooksPlugin",allowKeys:["addHooks","hooks"],hooks:{initPlugin:function(n,e){if(n.addHooks){i(Array.isArray(n.addHooks)||"object"!=typeof n.addHooks,`Error in plugin "${n.name}": config.addHooks must be an object but is a ${typeof n.addHooks}`,"config.addHooks.wrongtype");for(let o of Object.keys(n.addHooks))e.hooks[o]=n.addHooks[o]}if(n.hooks){i(Array.isArray(n.hooks)||"object"!=typeof n.hooks,`Error in plugin "${n.name}": config.hooks must be an object but is a ${typeof n.hooks}`,"config.hooks.wrongtype");for(let o of Object.keys(n.hooks))i(!e.hooks[o],'There is no Hook named "'+o+'", declared in plugin '+n.name+' . Is it correctly written? If yes, initialize it first with config attribute "addHooks"',"config.hooks.notDefined"),e.hooks[o].tap(n.name,n.hooks[o])}}},init:function(n,e){return e.config.hooks&&e.config.hooks.preInitPlugin&&e.hooks.preInitPlugin.tap("preInitPlugin",e.config.hooks.preInitPlugin),{addHooks:function(n){for(let o of Object.keys(n))e.hooks[o]=n[o]},on:function(n,o,i){if(!e.hooks[n])throw new Error('Hook with name "'+n+'" does not exist. context.on(name, pluginname, fn) failed');return e.hooks[n].tap(o,i)}}}}},new function(){return{allowKeys:["return"],name:"ReturnPlugin",hooks:{initPlugin(n,e){n.return&&(e.return=n.return)}}}},new function(){const n={};return{allowKeys:["rename"],name:"RenamePlugin",hooks:{initPlugin(e,o){if(e.rename){let o,i;for(i of Object.keys(e.rename))o=e.rename[i],n[i]=o}},return(e){let o,i;for(i of Object.keys(n))o=n[i],e[o]=e[i],delete e[i]}}}},new function(){const n=[];return{allowKeys:["delete"],name:"DeletePlugin",hooks:{initPlugin(e,o){e.delete&&n.push(...e.delete)},return(e){for(let o of n)delete e[o]}}}}]};class l{constructor(){this._listeners={}}tap(n,e){if(null==n)throw new Error("Hook.on(): should be on(name:string, listener:function) but name is undefined");if(null==e)throw new Error("Hook.on(): should be on(name:string, listener:function) but listener is undefined");this._listeners[n]=e}off(n){if(null==n)throw new Error("Hook.off(): should be on(name:string, listener:function) but name is undefined");delete this._listeners[n]}listeners(n){return n?this._listeners[n]:Object.values(this._listeners)}}class u extends l{call(n){const e=this.listeners();for(let n of e)n(...arguments)}}class s extends l{async promise(n){const e=this.listeners();for(let n of e)await n(...arguments)}}class a extends l{call(n){let e=n;const o=this.listeners();for(let n of o){if(null==e)throw new Error("A listener in SyncWaterfallHook.trigger(context) returns null. This is not allowed. Did you forget returning sth in a listener?");e=n(e,...arguments)}return e}}class f extends l{async promise(n){let e=n;const o=this.listeners();for(let n of o)e=await n(e,...arguments);return e}}const g=function n(e={},o={}){function l(o={}){const l=Object.assign({configs:[]},e);let g=Array.isArray(o)?o:[o];g=g.map((n=>(n.name=n.name||"pluginize(config)",n))),l.configs.push(...g);const c=function(n){async function e(n,o){if(o.log('- Add plugin "'+n.name+'"'),i(!(n=await o.hooks.preInitPlugin.promise(n,o)||n).name,`Plugin ${JSON.stringify(n)} has no name. Please define a name by adding an attribute name:"pluginname" to your plugin.`,"plugin.noName"),i("function"==typeof n,`Plugin ${n.name} is a function, but should be a configuration object. Did you forget calling it? (eg: PluginName())`,"plugin.isFunction"),i("object"!=typeof n||Array.isArray(n),`Plugin ${n.name} should be a configuration of type object, but is typeof ${typeof n}.`,"plugin.wrongType"),o.plugins.push(n),n.init){i("function"!=typeof n.init,`Error in plugin "${n.name}": config.init must be a function but is a ${typeof n.init}`,"config.init.wrongtype"),o.log("- Execute init() function of plugin "+n.name);const e=await n.init(n,o);if(e&&!e._context&&"object"==typeof e&&!Array.isArray(e))for(let n of Object.keys(e)||{})o.log("- add "+n+" to global context."),o[n]=e[n]}n.hooks&&n.hooks.initPlugin&&await o.hooks.initPlugin.tap(n.name,n.hooks.initPlugin),i(n.plugins&&!Array.isArray(n.plugins),`Error in plugin "${n.name}": config.plugin must be an array but is an ${typeof n.plugins}`,"config.plugin.wrongtype");for(let i of n.plugins||[])await e(i,o);return o}return async function(o={}){let l={plugins:[],config:o,_context:!0,addPlugin:e,hooks:{return:new s(["context"]),preInitPlugin:new f(["config","context"]),pluginsInitialized:new s(["context"]),initPlugin:new s(["plugin","context"])},log(){o.debug&&console.log(...arguments)}};n.preInit&&(o=await n.preInit(o,l)),i(null==o,"pluginize(config,factoryConfig): factoryConfig.preInit returns null but should return the modified config.","factoryConfig.preInit.isNull"),i("object"!=typeof o,"pluginize(config,factoryConfig): factoryConfig.preInit returns a "+typeof entry+"but should return an object.","factoryConfig.preInit.wrongType"),i(Array.isArray(o),"pluginize(config,factoryConfig): factoryConfig.preInit returns an Array but should return an object.","factoryConfig.preInit.wrongTypeArray"),o.debug&&t("development"),o.name||(o.name="PluginizeAsync"),l.log("Starting Pluginize."),await e(r,l);for(let o of n.configs)await e(o,l);await e(o,l);for(let n of l.plugins)i(null==n,"error in Pluginize(config): hook preInitPlugin - a listener returns null but should  return an object (the modified config)","config.preInit.returnNull"),i(Array.isArray(n)||"object"!=typeof n,"error in Pluginize(config): hook preInitPlugin - a listener should return an object (the modified config) but returns a "+typeof n,"config.preInit.wrongType"),l.log('- call hook "initPlugin" of plugin '+n.name),await l.hooks.initPlugin.promise(n,l);return l.log('- call hook "pluginsInitialized"'),await l.hooks.pluginsInitialized.promise(l),await l.hooks.return.promise(l),l.return?l[l.return]:l}}(l);return new n(l,{runPromise:c,run:function(n){function e(n,o){if(o.log('- Add plugin "'+n.name+'"'),i(null==(n=o.hooks.preInitPlugin.call(n,o)||n),"Error: Plugin is null","conf.isNull"),i(!n.name,`Plugin ${JSON.stringify(n)} has no name. Please define a name by adding an attribute name:"pluginname" to your plugin.`,"plugin.noName"),i("function"==typeof n,`Plugin ${n.name} is a function, but should be a configuration object. Did you forget calling it? (eg: PluginName())`,"plugin.isFunction"),i("object"!=typeof n||Array.isArray(n),`Plugin ${n.name} should be a configuration of type object, but is typeof ${typeof n}.`,"plugin.wrongType"),o.plugins.push(n),n.init){i("function"!=typeof n.init,`Error in plugin "${n.name}": config.init must be a function but is a ${typeof n.init}`,"config.init.wrongtype"),o.log("- Execute init() function of plugin "+n.name);const e=n.init(n,o);if(e&&!e._context&&"object"==typeof e&&!Array.isArray(e))for(let n of Object.keys(e)||{})o.log("- add "+n+" to global context."),o[n]=e[n]}n.hooks&&n.hooks.initPlugin&&o.hooks.initPlugin.tap(n.name,n.hooks.initPlugin),i(n.plugins&&!Array.isArray(n.plugins),`Error in plugin "${n.name}": config.plugin must be an array but is an ${typeof n.plugins}`,"config.plugin.wrongtype");for(let i of n.plugins||[])e(i,o);return o}return function(o={}){let l={plugins:[],config:o,_context:!0,addPlugin:e,hooks:{return:new u(["context"]),preInitPlugin:new a(["config","context"]),pluginsInitialized:new u(["context"]),initPlugin:new u(["plugin","context"])},log(){o.debug&&console.log(...arguments)}};const s=n.configs[n.configs.length-1];s.preInit&&(o=s.preInit(o,l)||o),i(null==o,"pluginize(config,factoryConfig): factoryConfig.preInit returns null but should return the modified config.","factoryConfig.preInit.isNull"),i("object"!=typeof o,"pluginize(config,factoryConfig): factoryConfig.preInit returns a "+typeof entry+"but should return an object.","factoryConfig.preInit.wrongType"),i(Array.isArray(o),"pluginize(config,factoryConfig): factoryConfig.preInit returns an Array but should return an object.","factoryConfig.preInit.wrongTypeArray"),o.debug&&t("development"),o.name||(o.name="Pluginize"),l.log("Starting Pluginize."),e(r,l);for(let o of n.configs)e(o,l);e(o,l);for(let n of l.plugins)i(null==n,"error in Pluginize(config): hook preInitPlugin - a listener returns null but should  return an object (the modified config)","config.preInit.returnNull"),i(Array.isArray(n)||"object"!=typeof n,"error in Pluginize(config): hook preInitPlugin - a listener should return an object (the modified config) but returns a "+typeof n,"config.preInit.wrongType"),l.log('- call hook "initPlugin" of plugin '+n.name),l.hooks.initPlugin.call(n,l);return l.log('- call hook "pluginsInitialized"'),l.hooks.pluginsInitialized.call(l),l.hooks.return.call(l),l.return?l[l.return]:l}}(l),factoryConfig:l})}for(let n of Object.keys(o))l[n]=o[n];return l}({});n.AsyncBreakableHook=class extends l{async call(n){const e=this.listeners();for(let n of e){if(!await n(...arguments))return}}},n.AsyncHook=s,n.AsyncWaterfallHook=f,n.SyncBreakableHook=class extends l{call(n){const e=this.listeners();for(let n of e){if(!n(...arguments))return}}},n.SyncHook=u,n.SyncWaterfallHook=a,n.pluginize=g,Object.defineProperty(n,"__esModule",{value:!0})}));
